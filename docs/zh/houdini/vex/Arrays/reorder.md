---
title: reorder
order: 12
category:
  - houdini
---
    
## 描述

Reorders items in an array or string. 根据新的索引列表重新排序。不改变原字符串/数组

```c
string  reorder(string value, int indices[])
```

Returns a reordered version of the _characters_ (not bytes) in the UTF-8
string `value` according to the positions in `indices`. The result is a UTF-8
encoded string.

根据新的索引列表（indices）重新排序字符串（values）。不改变原字符串。

返回 UTF-8 字符串值中的字符（不是字节）按照索引中的位置重新排序的版本。其结果是一个 UTF-8 编码的字符串。

```c
<type>[] reorder(<type>values[], int indices[])
```

Returns a reordered version of the items in `values` according to the
positions in `indices`. This usually uses a list of indices generated by [argsort](argsort.html "Returns the indices of a sorted version of an array."). See the argsort page for an example.

根据新的索引列表（indices）重新排序数组（values），不改变原数组。一般配合 argsort 使用

- Negative numbers in the index list will read from the end of the array.
- The length of the resulting array/string is the same as the length of the `indices`.
- Out of bound values will insert zeros, but this should be considered an error.

* 索引列表中的负数将从数组的末端读取。
* 产生的数组/字符串的长度与索引的长度相同。
* 超出范围的值将插入零，但这应该被认为是一个错误。

## 示例

字符串重排序

```c
string s1 = "world";
int ids[] = {4,3,2,1,0};
string s2;
s2 = reorder(s1,ids); // 用s2接受排序后的新字符串

printf("%s", s1);     // world。原字符串不变
printf("%s", s2);     // dlrow
```

数组重排序

```c
int arr1 [] = {1, 2, 3, 4};
int ids[] = {3,2,1,0};
int arr2[];
arr2 = reorder(arr1,ids);

printf("%s", arr1);     // {1, 2, 3, 4}
printf("%s", arr2);    // {4, 3, 2, 1}
```

## 示例 2：数组自定义排序

```c
// 字符串数组
string colors[] = {"Red", "Green", "Blue", "Orange", "Violet", "Indigo"};

// 基于元素长度，创建新数组（{3, 5, 4, 6, 6, 6}）
int lengths[] = {};

foreach (string name; colors) {
	push(lengths, len(name));
}

// 获取新的排序规则数组（{0, 2, 1, 3, 4, 5}）
int ordering[] = argsort(lengths);

// 基于排序规则 给原来的数组排序
string colors_by_len[] = reorder(colors, ordering);

printf ("%s\n", colors_by_len); // {Red, Blue, Green, Orange, Violet, Indigo}
```
